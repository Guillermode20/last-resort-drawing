<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Interface with Zoom</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            background: transparent;
            border: none;
        }
        #controls {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 4px;
            display: flex;
            gap: 5px;
            flex-wrap: nowrap;
            justify-content: center;
            max-width: 90vw;
            z-index: 1000;
        }
        .color-btn {
            width: 25px;
            height: 25px;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        .color-btn.active {
            transform: scale(1.2);
        }
        #width-control {
            width: 100px;
            margin: 0 5px;
        }
        button {
            padding: 5px 15px;
            border: none;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
        }
        button:hover {
            background: #eee;
        }
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border-radius: 4px;
            font-family: Arial, sans-serif;
        }
        #zoom-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 4px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
        #zoom-value {
            color: white;
            font-family: Arial, sans-serif;
            margin: 0 5px;
            min-width: 50px;
            text-align: center;
            line-height: 30px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">Connecting...</div>
    <div id="controls">
        <div class="color-btn active" style="background: #ff0000" data-color="#ff0000"></div>
        <div class="color-btn" style="background: #00ff00" data-color="#00ff00"></div>
        <div class="color-btn" style="background: #0000ff" data-color="#0000ff"></div>
        <div class="color-btn" style="background: #ffff00" data-color="#ffff00"></div>
        <div class="color-btn" style="background: #ff00ff" data-color="#ff00ff"></div>
        <div class="color-btn" style="background: #00ffff" data-color="#00ffff"></div>
        <div class="color-btn" style="background: #ffffff" data-color="#ffffff"></div>
        <input type="range" id="width-control" min="1" max="50" value="5">
        <button onclick="clearCanvas()">Clear</button>
    </div>
    <div id="zoom-controls">
        <button onclick="adjustZoom(0.1)">+</button>
        <span id="zoom-value">100%</span>
        <button onclick="adjustZoom(-0.1)">-</button>
        <button onclick="resetZoom()">Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const widthControl = document.getElementById('width-control');
        const zoomValueDisplay = document.getElementById('zoom-value');
        let ws = null;
        let isDrawing = false;
        let currentColor = '#ff0000';
        let currentWidth = 5;
        let currentPoints = [];
        let drawingState = []; // Store drawing state locally

        const VIRTUAL_WIDTH = 1920;  // Fixed virtual canvas width
        const VIRTUAL_HEIGHT = 1080; // Fixed virtual canvas height
        let scale = 1;
        let zoomLevel = 1;  // New zoom level variable
        let offsetX = 0;
        let offsetY = 0;
        let panOffsetX = 0;  // Additional offset for panning
        let panOffsetY = 0;
        
        // For panning functionality
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            updateScale();
        }

        function updateScale() {
            // Calculate the base scale to fit the virtual canvas while maintaining aspect ratio
            const containerAspectRatio = canvas.width / canvas.height;
            const virtualAspectRatio = VIRTUAL_WIDTH / VIRTUAL_HEIGHT;
            
            let baseScale;
            if (containerAspectRatio > virtualAspectRatio) {
                // Window is wider than needed
                baseScale = canvas.height / VIRTUAL_HEIGHT;
                offsetX = (canvas.width - VIRTUAL_WIDTH * baseScale) / 2;
                offsetY = 0;
            } else {
                // Window is taller than needed
                baseScale = canvas.width / VIRTUAL_WIDTH;
                offsetX = 0;
                offsetY = (canvas.height - VIRTUAL_HEIGHT * baseScale) / 2;
            }

            // Apply the zoom level to the base scale
            scale = baseScale * zoomLevel;
            
            // Recalculate offsets with zoom and pan
            const zoomedWidth = VIRTUAL_WIDTH * scale;
            const zoomedHeight = VIRTUAL_HEIGHT * scale;
            
            // Calculate center point
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Apply transform with zoom and pan
            ctx.setTransform(
                scale, 0, 0, scale, 
                centerX - (VIRTUAL_WIDTH / 2 * scale) + panOffsetX,
                centerY - (VIRTUAL_HEIGHT / 2 * scale) + panOffsetY
            );
            
            // Position controls below virtual canvas
            updateControlsPosition();
        }

        function clearAndDrawBorder() {
            // Clear the entire canvas
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            // Draw border around virtual canvas
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2 / zoomLevel; // Adjust border width based on zoom
            ctx.strokeRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
        }

        function updateControlsPosition() {
            const controls = document.getElementById('controls');
            // Position controls at the bottom of the screen
            controls.style.bottom = '10px';
            controls.style.top = 'auto';
        }

        function adjustZoom(delta) {
            const newZoom = Math.max(0.1, Math.min(5, zoomLevel + delta));
            zoomLevel = newZoom;
            zoomValueDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            updateScale();
            redrawCanvasWithState();
        }

        function resetZoom() {
            zoomLevel = 1;
            panOffsetX = 0;
            panOffsetY = 0;
            zoomValueDisplay.textContent = '100%';
            updateScale();
            redrawCanvasWithState();
        }

        function startPanning(e) {
            if (e.button === 1 || (e.button === 0 && e.altKey)) { // Middle button or Alt+Left click
                isPanning = true;
                const x = e.touches ? e.touches[0].clientX : e.clientX;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                lastPanPoint = { x, y };
                e.preventDefault();
            }
        }

        function pan(e) {
            if (!isPanning) return;
            e.preventDefault();

            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            
            const dx = x - lastPanPoint.x;
            const dy = y - lastPanPoint.y;
            
            panOffsetX += dx;
            panOffsetY += dy;
            
            lastPanPoint = { x, y };
            
            updateScale();
            redrawCanvasWithState();
        }

        function endPanning() {
            isPanning = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 0.1 : -0.1;
            adjustZoom(delta);
        }

        function redrawCanvasWithState() {
            // Clear with proper transform and draw border
            clearAndDrawBorder();

            // Redraw all stored strokes
            drawingState.forEach(item => {
                const points = item.points;
                if (points.length === 1) {
                    drawPoint({ x: points[0].x, y: points[0].y }, item.color, item.width);
                } else {
                    // Draw the complete stroke with all points
                    ctx.beginPath();
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = item.width;
                    ctx.moveTo(points[0].x * VIRTUAL_WIDTH, points[0].y * VIRTUAL_HEIGHT);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x * VIRTUAL_WIDTH, points[i].y * VIRTUAL_HEIGHT);
                    }
                    ctx.stroke();
                }
            });
        }

        function connectWebSocket() {
            const localWsUrl = 'ws://127.0.0.1:8000/ws/draw';
            const gcpWsUrl = 'ws://34.148.39.39:8080/ws/draw';
            let wsUrl = null;

            function attemptConnection(url) {
                wsUrl = url;
                ws = new WebSocket(url);

                ws.onopen = () => {
                    status.textContent = 'Connected to: ' + url;
                    // Request current state when connecting
                    ws.send(JSON.stringify({ type: 'join', client: 'draw' }));
                };

                ws.onclose = () => {
                    status.textContent = 'Disconnected from: ' + url + ' - Trying other server...';
                    if (wsUrl === localWsUrl) {
                        attemptConnection(gcpWsUrl);
                    } else {
                        status.textContent = 'Failed to connect to both servers.';
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'clear') {
                        clearCanvas(false);
                        drawingState = []; // Clear local state
                    } else if (data.type === 'state') {
                        // Update local state
                        drawingState = data.state.filter(item => item.type === 'draw');
                        // Redraw with the new state
                        redrawCanvasWithState();
                    }
                };
            }

            attemptConnection(localWsUrl);
        }

        function startDrawing(e) {
            // Don't start drawing if we're panning
            if (isPanning || (e.button === 1 || (e.button === 0 && e.altKey))) return;
            
            isDrawing = true;
            currentPoints = [];
            const point = getPoint(e);
            currentPoints.push(point);
            ctx.beginPath();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentWidth;
            ctx.moveTo(point.x * VIRTUAL_WIDTH, point.y * VIRTUAL_HEIGHT);
        }

        let batchTimeout = null;
        let pendingPoints = [];

        function draw(e) {
            if (!isDrawing || isPanning) return;
            e.preventDefault();

            const point = getPoint(e);
            currentPoints.push(point);
            
            // Draw immediately on canvas with improved interpolation
            if (currentPoints.length >= 2) {
                const lastPoint = currentPoints[currentPoints.length - 2];
                const currentPoint = point;
                
                // Calculate distance between points
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Create interpolated points for smoother lines
                const interpolatedPoints = [];
                const minDistance = 0.002; // Smaller value for more precise interpolation
                
                if (dist > minDistance) {
                    const steps = Math.ceil(dist / minDistance);
                    for (let i = 0; i <= steps; i++) {
                        const t = i / steps;
                        interpolatedPoints.push({
                            x: lastPoint.x + dx * t,
                            y: lastPoint.y + dy * t
                        });
                    }
                } else {
                    interpolatedPoints.push(currentPoint);
                }
                
                // Draw the interpolated points
                ctx.beginPath();
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentWidth;
                ctx.moveTo(lastPoint.x * VIRTUAL_WIDTH, lastPoint.y * VIRTUAL_HEIGHT);
                
                interpolatedPoints.forEach(p => {
                    ctx.lineTo(p.x * VIRTUAL_WIDTH, p.y * VIRTUAL_HEIGHT);
                    pendingPoints.push(p);
                });
                
                ctx.stroke();
            }

            // Send points more frequently with smaller batches
            if (!batchTimeout) {
                batchTimeout = setTimeout(() => {
                    if (pendingPoints.length > 0) {
                        const pointsToSend = pendingPoints.slice();
                        pendingPoints = [];
                        const drawData = {
                            type: 'draw',
                            points: pointsToSend,
                            color: currentColor,
                            width: currentWidth
                        };
                        
                        // Send to server
                        ws.send(JSON.stringify(drawData));
                        
                        // Add to local drawing state
                        drawingState.push(drawData);
                    }
                    batchTimeout = null;
                }, 1);
            }
        }

        function endDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
        
            // Clear any pending batch timeout
            if (batchTimeout) {
                clearTimeout(batchTimeout);
                batchTimeout = null;
            }
        
            // Send any remaining points
            if (pendingPoints.length > 0) {
                const drawData = {
                    type: 'draw',
                    points: pendingPoints,
                    color: currentColor,
                    width: currentWidth
                };
                
                ws.send(JSON.stringify(drawData));
                drawingState.push(drawData);
                pendingPoints = [];
            }
        }

        function getPoint(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX);
            const y = (e.touches ? e.touches[0].clientY : e.clientY);
            
            // Get the current transform matrix
            const transform = ctx.getTransform();
            
            // Convert screen coordinates to canvas coordinates
            const transformedX = (x - transform.e) / transform.a;
            const transformedY = (y - transform.f) / transform.d;
            
            // Normalize to 0-1 range and clamp
            return {
                x: Math.max(0, Math.min(1, transformedX / VIRTUAL_WIDTH)),
                y: Math.max(0, Math.min(1, transformedY / VIRTUAL_HEIGHT))
            };
        }

        function drawPoint(point, color = currentColor, width = currentWidth) {
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(point.x * VIRTUAL_WIDTH, point.y * VIRTUAL_HEIGHT, width / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function clearCanvas(broadcast = true) {
            clearAndDrawBorder();
            drawingState = []; // Clear local state
            if (broadcast) {
                ws.send(JSON.stringify({ type: 'clear' }));
            }
        }

        function redrawCanvas() {
            // Request current state
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                connectWebSocket();
                return;
            }
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'join', client: 'draw' }));
            }
        }

        // Event Listeners
        canvas.addEventListener('mousedown', function(e) {
            if (e.button === 1 || (e.button === 0 && e.altKey)) {
                startPanning(e);
            } else {
                startDrawing(e);
            }
        });
        canvas.addEventListener('mousemove', function(e) {
            if (isPanning) {
                pan(e);
            } else {
                draw(e);
            }
        });
        canvas.addEventListener('mouseup', function(e) {
            if (isPanning) {
                endPanning();
            } else {
                endDrawing();
            }
        });
        canvas.addEventListener('mouseleave', function() {
            endPanning();
            endDrawing();
        });

        // Touch events
        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                startPanning(e);
            } else {
                startDrawing(e);
            }
        });
        canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                pan(e);
            } else {
                draw(e);
            }
        });
        canvas.addEventListener('touchend', function() {
            endPanning();
            endDrawing();
        });

        // Wheel event for zooming
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.color-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentColor = btn.dataset.color;
            });
        });

        widthControl.addEventListener('input', (e) => {
            currentWidth = parseInt(e.target.value);
        });

        window.onresize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateScale();
            redrawCanvasWithState();
        };

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === '=' || e.key === '+') {
                adjustZoom(0.1);
            } else if (e.key === '-' || e.key === '_') {
                adjustZoom(-0.1);
            } else if (e.key === '0') {
                resetZoom();
            }
        });

        initCanvas();
        connectWebSocket();
    </script>
</body>
</html>